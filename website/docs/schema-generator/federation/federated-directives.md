---
id: federated-directives
title: Federated Directives
---
`graphql-kotlin` supports a number of directives that can be used to annotate a schema and direct certain behaviors.

For more details, see the [Apollo Federation Specification](https://www.apollographql.com/docs/federation/federation-spec/).

## `@contact` directive

```graphql
directive @contact(
  "Contact title of the subgraph owner"
  name: String!
  "URL where the subgraph's owner can be reached"
  url: String
  "Other relevant notes can be included here; supports markdown links"
  description: String
) on SCHEMA
```

Contact schema directive can be used to provide team contact information to your subgraph schema. This information is automatically parsed and displayed by Apollo Studio.
See [Subgraph Contact Information](https://www.apollographql.com/docs/studio/federated-graphs/#subgraph-contact-info) for additional details.

#### Example usage on the schema class:

```kotlin
@ContactDirective(
  name = "My Team Name",
  url = "https://myteam.slack.com/archives/teams-chat-room-url",
  description = "send urgent issues to [#oncall](https://yourteam.slack.com/archives/oncall)."
)
class MySchema
```

will generate

```graphql
schema @contact(description : "send urgent issues to [#oncall](https://yourteam.slack.com/archives/oncall).", name : "My Team Name", url : "https://myteam.slack.com/archives/teams-chat-room-url"){
  query: Query
}
```

## `@extends` directive

:::caution
While Federation v2 no longer requires `@extends` directive due to the smart entity type merging. `graphql-kotlin` still
requires `@extends` directive to programmatically locate all federated  entity types in order to add them to the schema.
:::

```graphql
directive @extends on OBJECT | INTERFACE
```

`@extends` directive is used to represent type extensions in the schema. Native type extensions are currently
unsupported by the `graphql-kotlin` libraries. Federated extended types should have corresponding `@key` directive
defined that specifies primary key required to fetch the underlying object.

#### Example

```kotlin
@KeyDirective(FieldSet("id"))
@ExtendsDirective
class Product(@ExternalDirective val id: String) {
   fun newFunctionality(): String = "whatever"
}
```

will generate

```graphql
type Product @key(fields : "id") @extends {
  id: String! @external
  newFunctionality: String!
}
```

## `@external` directive

```graphql
directive @external on FIELD_DEFINITION
```

The `@external` directive is used to mark a field as owned by another service. This allows service A to use fields from
service B while also knowing at runtime the types of that field. `@external` directive is only applicable on federated
extended types. All the external fields should either be referenced from the `@key`, `@requires` or `@provides`
directives field sets.

Due to the smart merging of entity types, `@external` directive is no longer required on `@key` fields and can be omitted
from the schema. `@external` directive is only required on fields referenced by the `@requires` and `@provides` directive.

#### Example

```kotlin
@KeyDirective(FieldSet("id"))
@ExtendsDirective
class Product(@ExternalDirective val id: String) {
  fun newFunctionality(): String = "whatever"
}
```

will generate

```graphql
type Product @key(fields : "id") @extends {
  id: String! @external
  newFunctionality: String!
}
```

## `@inaccessible` directive

:::note
Only available in Federation v2.
:::

```graphql
directive @inaccessible on FIELD_DEFINITION
    | OBJECT
    | INTERFACE
    | UNION
    | ENUM
    | ENUM_VALUE
    | SCALAR
    | INPUT_OBJECT
    | INPUT_FIELD_DEFINITION
    | ARGUMENT_DEFINITION
```

Inaccessible directive marks location within schema as inaccessible from the GraphQL Gateway. This allows you to incrementally add schema elements (e.g. fields) to multiple subgraphs without breaking composition.
See [@inaccessible specification](https://specs.apollo.dev/inaccessible/v0.2) for additional details.

:::caution
Location within schema will be inaccessible from the GraphQL Gateway as long as **ANY** of the subgraphs marks that location as `@inacessible`.
:::

#### Example

```kotlin
class Product(
  val id: String,
  @InaccessibleDirective
  val secret: String
)
```

will be generated by the subgraph as

```graphql
type Product {
  id: String!
  secret: String! @inaccessible
}
```

but will be exposed on the GraphQL Gateway as

```graphql
type Product {
  id: String!
}
```

## `@key` directive

```graphql
# federation v1 definition
directive @key(fields: _FieldSet!) repeatable on OBJECT | INTERFACE

# federation v2 definition
directive @key(fields: _FieldSet!, resolvable: Boolean) repeatable on OBJECT | INTERFACE
```

The `@key` directive is used to indicate a combination of fields that can be used to uniquely identify and fetch an
object or interface. The specified field set can represent single field (e.g. `"id"`), multiple fields (e.g. `"id name"`) or
nested selection sets (e.g. `"id user { name }"`). Multiple keys can be specified on a target type.

Key directives should be specified on the root base type as well as all the corresponding federated (i.e. extended)
types. Key fields specified in the directive field set should correspond to a valid field on the underlying GraphQL
interface/object. Federated extended types should also instrument all the referenced key fields with `@external`
directive.

#### Basic Example

```kotlin
@KeyDirective(FieldSet("id"))
@KeyDirective(FieldSet("upc"))
class Product(val id: String, val upc: String, val name: String)
```

will generate

```graphql
type Product @key(fields: "id") @key(fields: "upc") {
  id: String!
  name: String!
  upc: String!
}
```

#### Referencing External Entities

Entity types can be referenced from other subgraphs without contributing any additional fields, i.e. we can update type within our schema with a reference to a federated type. In order to generate
a valid schema, we need to define **stub** for federated entity that contains only key fields and also mark it as not resolvable within our subgraph. For example, if we have `Review` entity defined
in our supergraph, we can reference it in our product schema using following code

```kotlin
@KeyDirective(fields = FieldSet("id"))
class Product(val id: String, val name: String, val reviews: List<Review>)

// review stub referencing just the key fields
@KeyDirective(fields = FieldSet("id"), resolvable = false)
class Review(val id: String)
```

which will generate

```graphql
type Product @key(fields: "id") {
  id: String!
  name: String!
  reviews: [Review!]!
}

type Review @key(fields: "id", resolvable: false) {
  id: String!
}
```

This allows end users to query GraphQL Gateway for any product review fields and they will be resolved by calling the appropriate subgraph.

## `@link` directive

:::note
Only available in Federation v2.
:::

```graphql
directive @link(url: String, import: [String!]) repeatable on SCHEMA
```

The `@link` directive links definitions within the document to external schemas. See [@link specification](https://specs.apollo.dev/link/v1.0) for details.

External schemas are identified by their `url`, which optionally ends with a name and version with the following format: `{NAME}/v{MAJOR}.{MINOR}`.

By default, external types should be namespaced (prefixed with `<namespace>__`, e.g. `key` directive should be namespaced as `federation__key`) unless they are explicitly imported.
`graphql-kotlin` automatically imports ALL federation directives to avoid the need for namespacing.

:::danger
We currently DO NOT support full `@link` directive capability as it requires support for namespacing and renaming imports. This functionality may be added in the future releases. See
[@link specification](https://specs.apollo.dev/link/v1.0) for details.
:::

## `@override` directive

:::note
Only available in Federation v2.
:::

```graphql
directive @override(from: String!) on FIELD_DEFINITION
```

The `@override` directive is used to indicate that the current subgraph is taking responsibility for resolving the marked field away from the subgraph specified in the `from` argument,
i.e. it is used for migrating a field from one subgraph to another. Name of the subgraph to be overriden has to match the name of the subgraph that was used to publish their schema. See
[Publishing schema to Apollo Studio](https://www.apollographql.com/docs/rover/subgraphs/#publishing-a-subgraph-schema-to-apollo-studio) for additional details.

:::caution
Only one subgraph can `@override` any given field. If multiple subgraphs attempt to `@override` the same field, a composition error occurs.
:::

#### Example

Given `SubgraphA`

```graphql
type Product @key(fields: "id") {
    id: String!
    description: String!
}
```

We can override gateway `description` field resolution to resolve it in the `SubgraphB`

```graphql
type Product @key(fields: "id") {
    id: String!
    name: String!
    description: String! @override(from: "SubgraphA")
}
```

## `@provides` directive

```graphql
directive @provides(fields: _FieldSet!) on FIELD_DEFINITION
```

The `@provides` directive is used to annotate the expected returned field set from a field on a base type that is
guaranteed to be selectable by the gateway. This allows you to expose only a subset of fields from the underlying
federated object type to be selectable from the federated schema. Provided fields specified in the directive field set
should correspond to a valid field on the underlying GraphQL interface/object type. `@provides` directive can only be
used on fields returning federated extended objects.

#### Example 1:

:::info
Due to the smart entity type merging, Federation v2 does not require `@provides` directive if field can always be resolved locally.
:::

We might want to expose only name of the user that submitted a review.

```kotlin
@KeyDirective(FieldSet("id"))
class Review(val id: String) {
  @ProvidesDirective(FieldSet("name"))
  fun user(): User = getUserByReviewId(id)
}

@KeyDirective(FieldSet("userId"))
@ExtendsDirective
class User(
  @ExternalDirective val userId: String,
  @ExternalDirective val name: String
)
```

will generate

```graphql
type Review @key(fields : "id") {
  id: String!
  user: User! @provides(fields : "name")
}

type User @key(fields : "userId") @extends {
  userId: String! @external
  name: String! @external
}
```

#### Example 2:

Within our service, one of the queries could resolve all fields locally while other requires resolution from other subgraph

```graphql
type Query {
  remoteResolution: Foo
  localOnly: Foo @provides("baz")
}

type Foo @key("id") {
  id: ID!
  bar: Bar
  baz: Baz @external
}
```

In the example above, if user selects `baz` field, it will be resolved locally from `localOnly` query but will require another subgraph invocation from `remoteResolution` query.

## `@requires` directive

```graphql
directive @requires(fields: _FieldSet!) on FIELD_DEFINITON
```

The `@requires` directive is used to annotate the required input field set from a base type for a resolver. It is used
to develop a query plan where the required fields may not be needed by the client, but the service may need additional
information from other services. Required fields specified in the directive field set should correspond to a valid field
on the underlying GraphQL interface/object and should be instrumented with `@external` directive. Since `@requires`
directive specifies additional fields (besides the one specified in `@key` directive) that are required to resolve
federated type fields, this directive can only be specified on federated extended objects fields.

Fields specified in the `@requires` directive will only be specified in the queries that reference those fields.
This is problematic for Kotlin as the non nullable primitive properties have to be initialized when they are declared.
Simplest workaround for this problem is to initialize the underlying property to some dummy value that will be used if
it is not specified. This approach might become problematic though as it might be impossible to determine whether fields
was initialized with the default value or the invalid/default value was provided by the federated query. Another
potential workaround is to rely on delegation to initialize the property after the object gets created. This will ensure
that exception will be thrown if queries attempt to resolve fields that reference the uninitialized property.

#### Example

```kotlin
@KeyDirective(FieldSet("id"))
@ExtendsDirective
class Product(@ExternalDirective val id: String) {
  @ExternalDirective
  var weight: Double by Delegates.notNull()

  @RequiresDirective(FieldSet("weight"))
  fun shippingCost(): String { ... }

  fun additionalInfo(): String { ... }
}
```

will generate

```graphql
type Product @key(fields : "id") @extends  {
  additionalInfo: String!
  id: String! @external
  shippingCost: String! @requires(fields : "weight")
  weight: Float! @external
}
```

## `@shareable` directive

:::note
Only available in Federation v2.
:::

```graphql
directive @shareable on FIELD_DEFINITION | OBJECT
```

Shareable directive indicates that given object and/or field can be resolved by multiple subgraphs. If an object is marked as `@shareable` then all its fields are automatically shareable without the
need for explicitly marking them with `@shareable` directive. All fields referenced from `@key` directive are automatically shareable as well.

:::caution
Objects/fields have to specify same shareability (i.e. `@shareable` or not) mode across ALL subgraphs.
:::

#### Example

```graphql
type Product @key(fields: "id") {
  id: ID!                           # shareable because id is a key field
  name: String                      # non-shareable
  description: String @shareable    # shareable
}

type User @key(fields: "email") @shareable {
  email: String                    # shareable because User is marked shareable
  name: String                     # shareable because User is marked shareable
}
```

## `@tag` directive

```graphql
directive @tag(name: String!) repeatable on FIELD_DEFINITION
    | OBJECT
    | INTERFACE
    | UNION
    | ARGUMENT_DEFINITION
    | SCALAR
    | ENUM
    | ENUM_VALUE
    | INPUT_OBJECT
    | INPUT_FIELD_DEFINITION
```

Tag directive allows users to annotate fields and types with additional metadata information. Used by [Apollo Contracts](https://www.apollographql.com/docs/studio/contracts/) to expose
different graph variants to different customers. See [@tag specification](https://specs.apollo.dev/tag/v0.2/) for details.

#### Example

```graphql
type Product @tag(name: "MyCustomTag") {
    id: String!
    name: String!
}
```

:::caution
Apollo Contracts behave slightly differently depending on which version of Apollo Federation your graph uses (1 or 2). See [documentation](https://www.apollographql.com/docs/studio/contracts/#federation-1-limitations) for details.
:::
